// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: user_accounts_join.sql

package queries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countUserAccountsJoins = `-- name: CountUserAccountsJoins :one
SELECT COUNT(*) FROM user_accounts_join
`

func (q *Queries) CountUserAccountsJoins(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserAccountsJoins)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserAccountsJoin = `-- name: CreateUserAccountsJoin :exec
INSERT INTO user_accounts_join (user_id, account_id, role_id) VALUES ($1, $2, $3) on conflict (user_id, account_id) do update set role_id = $3
`

type CreateUserAccountsJoinParams struct {
	UserID    uuid.UUID
	AccountID uuid.UUID
	RoleID    int32
}

func (q *Queries) CreateUserAccountsJoin(ctx context.Context, arg CreateUserAccountsJoinParams) error {
	_, err := q.db.ExecContext(ctx, createUserAccountsJoin, arg.UserID, arg.AccountID, arg.RoleID)
	return err
}

const deleteUserAccountsJoin = `-- name: DeleteUserAccountsJoin :exec
DELETE FROM user_accounts_join WHERE user_id = $1 AND account_id = $2
`

type DeleteUserAccountsJoinParams struct {
	UserID    uuid.UUID
	AccountID uuid.UUID
}

func (q *Queries) DeleteUserAccountsJoin(ctx context.Context, arg DeleteUserAccountsJoinParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserAccountsJoin, arg.UserID, arg.AccountID)
	return err
}

const getAccountByAccountID = `-- name: GetAccountByAccountID :one
SELECT id, name, picture, email, sub, prefered_username, access_token, refresh_token, iss, created_at, expired_at, scope, user_id, account_id, role_id FROM accounts INNER JOIN user_accounts_join ON accounts.id = user_accounts_join.account_id WHERE account_id = $1
`

type GetAccountByAccountIDRow struct {
	ID               uuid.UUID
	Name             string
	Picture          string
	Email            string
	Sub              string
	PreferedUsername string
	AccessToken      string
	RefreshToken     string
	Iss              string
	CreatedAt        time.Time
	ExpiredAt        time.Time
	Scope            string
	UserID           uuid.UUID
	AccountID        uuid.UUID
	RoleID           int32
}

func (q *Queries) GetAccountByAccountID(ctx context.Context, accountID uuid.UUID) (GetAccountByAccountIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByAccountID, accountID)
	var i GetAccountByAccountIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Picture,
		&i.Email,
		&i.Sub,
		&i.PreferedUsername,
		&i.AccessToken,
		&i.RefreshToken,
		&i.Iss,
		&i.CreatedAt,
		&i.ExpiredAt,
		&i.Scope,
		&i.UserID,
		&i.AccountID,
		&i.RoleID,
	)
	return i, err
}

const getUserAccountsJoin = `-- name: GetUserAccountsJoin :one
SELECT user_id, account_id, role_id FROM user_accounts_join WHERE user_id = $1 AND account_id = $2
`

type GetUserAccountsJoinParams struct {
	UserID    uuid.UUID
	AccountID uuid.UUID
}

func (q *Queries) GetUserAccountsJoin(ctx context.Context, arg GetUserAccountsJoinParams) (UserAccountsJoin, error) {
	row := q.db.QueryRowContext(ctx, getUserAccountsJoin, arg.UserID, arg.AccountID)
	var i UserAccountsJoin
	err := row.Scan(&i.UserID, &i.AccountID, &i.RoleID)
	return i, err
}

const getUserAccountsJoinByUserID = `-- name: GetUserAccountsJoinByUserID :many
SELECT user_id, account_id, role_id, id, name, picture, email, sub, prefered_username, access_token, refresh_token, iss, created_at, expired_at, scope FROM user_accounts_join INNER JOIN accounts ON user_accounts_join.account_id = accounts.id WHERE user_id = $1
`

type GetUserAccountsJoinByUserIDRow struct {
	UserID           uuid.UUID
	AccountID        uuid.UUID
	RoleID           int32
	ID               uuid.UUID
	Name             string
	Picture          string
	Email            string
	Sub              string
	PreferedUsername string
	AccessToken      string
	RefreshToken     string
	Iss              string
	CreatedAt        time.Time
	ExpiredAt        time.Time
	Scope            string
}

func (q *Queries) GetUserAccountsJoinByUserID(ctx context.Context, userID uuid.UUID) ([]GetUserAccountsJoinByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAccountsJoinByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAccountsJoinByUserIDRow
	for rows.Next() {
		var i GetUserAccountsJoinByUserIDRow
		if err := rows.Scan(
			&i.UserID,
			&i.AccountID,
			&i.RoleID,
			&i.ID,
			&i.Name,
			&i.Picture,
			&i.Email,
			&i.Sub,
			&i.PreferedUsername,
			&i.AccessToken,
			&i.RefreshToken,
			&i.Iss,
			&i.CreatedAt,
			&i.ExpiredAt,
			&i.Scope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAccountsJoins = `-- name: ListUserAccountsJoins :many
SELECT user_id, account_id, role_id FROM user_accounts_join
`

func (q *Queries) ListUserAccountsJoins(ctx context.Context) ([]UserAccountsJoin, error) {
	rows, err := q.db.QueryContext(ctx, listUserAccountsJoins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAccountsJoin
	for rows.Next() {
		var i UserAccountsJoin
		if err := rows.Scan(&i.UserID, &i.AccountID, &i.RoleID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAccountsJoin = `-- name: UpdateUserAccountsJoin :exec
UPDATE user_accounts_join SET updated_at = now() WHERE user_id = $1 AND account_id = $2
`

type UpdateUserAccountsJoinParams struct {
	UserID    uuid.UUID
	AccountID uuid.UUID
}

func (q *Queries) UpdateUserAccountsJoin(ctx context.Context, arg UpdateUserAccountsJoinParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAccountsJoin, arg.UserID, arg.AccountID)
	return err
}

const userAccountsJoinExistByAccountID = `-- name: UserAccountsJoinExistByAccountID :one
SELECT EXISTS (SELECT 1 FROM user_accounts_join WHERE account_id = $1)
`

func (q *Queries) UserAccountsJoinExistByAccountID(ctx context.Context, accountID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, userAccountsJoinExistByAccountID, accountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
